// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: def.proto

package def

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// Validate checks the field values on RType with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *RType) Validate() error {
	if m == nil {
		return nil
	}

	if !_RType_From_Pattern.MatchString(m.GetFrom()) {
		return RTypeValidationError{
			field:  "From",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if !_RType_To_Pattern.MatchString(m.GetTo()) {
		return RTypeValidationError{
			field:  "To",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if !_RType_Verb_Pattern.MatchString(m.GetVerb()) {
		return RTypeValidationError{
			field:  "Verb",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	// no validation rules for Multiple

	// no validation rules for CountType

	return nil
}

// RTypeValidationError is the validation error returned by RType.Validate if
// the designated constraints aren't met.
type RTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RTypeValidationError) ErrorName() string { return "RTypeValidationError" }

// Error satisfies the builtin error interface
func (e RTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RTypeValidationError{}

var _RType_From_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

var _RType_To_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

var _RType_Verb_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on EType with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *EType) Validate() error {
	if m == nil {
		return nil
	}

	if !_EType_Name_Pattern.MatchString(m.GetName()) {
		return ETypeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	return nil
}

// ETypeValidationError is the validation error returned by EType.Validate if
// the designated constraints aren't met.
type ETypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ETypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ETypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ETypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ETypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ETypeValidationError) ErrorName() string { return "ETypeValidationError" }

// Error satisfies the builtin error interface
func (e ETypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ETypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ETypeValidationError{}

var _EType_Name_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on E with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *E) Validate() error {
	if m == nil {
		return nil
	}

	if !_E_Type_Pattern.MatchString(m.GetType()) {
		return EValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	// no validation rules for ID

	// no validation rules for ID1

	// no validation rules for ID2

	// no validation rules for ID3

	// no validation rules for CTime

	// no validation rules for UTime

	// no validation rules for State

	// no validation rules for Meta

	// no validation rules for Content

	// no validation rules for Score

	// no validation rules for Score1

	return nil
}

// EValidationError is the validation error returned by E.Validate if the
// designated constraints aren't met.
type EValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EValidationError) ErrorName() string { return "EValidationError" }

// Error satisfies the builtin error interface
func (e EValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EValidationError{}

var _E_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on DefineETypeReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *DefineETypeReq) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetEType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefineETypeReqValidationError{
				field:  "EType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCreationRTypes() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DefineETypeReqValidationError{
					field:  fmt.Sprintf("CreationRTypes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// DefineETypeReqValidationError is the validation error returned by
// DefineETypeReq.Validate if the designated constraints aren't met.
type DefineETypeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefineETypeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefineETypeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefineETypeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefineETypeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefineETypeReqValidationError) ErrorName() string { return "DefineETypeReqValidationError" }

// Error satisfies the builtin error interface
func (e DefineETypeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefineETypeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefineETypeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefineETypeReqValidationError{}

// Validate checks the field values on CreateEWithRsReq with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *CreateEWithRsReq) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetE()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateEWithRsReqValidationError{
				field:  "E",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRelated() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateEWithRsReqValidationError{
					field:  fmt.Sprintf("Related[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// CreateEWithRsReqValidationError is the validation error returned by
// CreateEWithRsReq.Validate if the designated constraints aren't met.
type CreateEWithRsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEWithRsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEWithRsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEWithRsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEWithRsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEWithRsReqValidationError) ErrorName() string { return "CreateEWithRsReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateEWithRsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEWithRsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEWithRsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEWithRsReqValidationError{}

// Validate checks the field values on RelationReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *RelationReq) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationReqValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationReqValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if !_RelationReq_Verb_Pattern.MatchString(m.GetVerb()) {
		return RelationReqValidationError{
			field:  "Verb",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	return nil
}

// RelationReqValidationError is the validation error returned by
// RelationReq.Validate if the designated constraints aren't met.
type RelationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationReqValidationError) ErrorName() string { return "RelationReqValidationError" }

// Error satisfies the builtin error interface
func (e RelationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationReqValidationError{}

var _RelationReq_Verb_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on GetByIDsReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *GetByIDsReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_GetByIDsReq_Type_Pattern.MatchString(m.GetType()) {
		return GetByIDsReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	return nil
}

// GetByIDsReqValidationError is the validation error returned by
// GetByIDsReq.Validate if the designated constraints aren't met.
type GetByIDsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetByIDsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetByIDsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetByIDsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetByIDsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetByIDsReqValidationError) ErrorName() string { return "GetByIDsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetByIDsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetByIDsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetByIDsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetByIDsReqValidationError{}

var _GetByIDsReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on EList with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *EList) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EListValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// EListValidationError is the validation error returned by EList.Validate if
// the designated constraints aren't met.
type EListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EListValidationError) ErrorName() string { return "EListValidationError" }

// Error satisfies the builtin error interface
func (e EListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EListValidationError{}

// Validate checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Empty) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// EmptyValidationError is the validation error returned by Empty.Validate if
// the designated constraints aren't met.
type EmptyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyValidationError) ErrorName() string { return "EmptyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmpty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyValidationError{}

// Validate checks the field values on HasRelationResp with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *HasRelationResp) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Has

	return nil
}

// HasRelationRespValidationError is the validation error returned by
// HasRelationResp.Validate if the designated constraints aren't met.
type HasRelationRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HasRelationRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HasRelationRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HasRelationRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HasRelationRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HasRelationRespValidationError) ErrorName() string { return "HasRelationRespValidationError" }

// Error satisfies the builtin error interface
func (e HasRelationRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHasRelationResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HasRelationRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HasRelationRespValidationError{}

// Validate checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Query) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetField()) < 1 {
		return QueryValidationError{
			field:  "Field",
			reason: "value length must be at least 1 runes",
		}
	}

	// no validation rules for Op

	// no validation rules for Value

	// no validation rules for ValueType

	return nil
}

// QueryValidationError is the validation error returned by Query.Validate if
// the designated constraints aren't met.
type QueryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryValidationError) ErrorName() string { return "QueryValidationError" }

// Error satisfies the builtin error interface
func (e QueryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryValidationError{}

// Validate checks the field values on Limit with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Limit) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for From

	// no validation rules for Limit

	return nil
}

// LimitValidationError is the validation error returned by Limit.Validate if
// the designated constraints aren't met.
type LimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LimitValidationError) ErrorName() string { return "LimitValidationError" }

// Error satisfies the builtin error interface
func (e LimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LimitValidationError{}

// Validate checks the field values on Update with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Update) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetField()) < 1 {
		return UpdateValidationError{
			field:  "Field",
			reason: "value length must be at least 1 runes",
		}
	}

	// no validation rules for Action

	// no validation rules for Value

	// no validation rules for ValueType

	return nil
}

// UpdateValidationError is the validation error returned by Update.Validate if
// the designated constraints aren't met.
type UpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateValidationError) ErrorName() string { return "UpdateValidationError" }

// Error satisfies the builtin error interface
func (e UpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateValidationError{}

// Validate checks the field values on Paged with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Paged) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PagedValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HasMore

	// no validation rules for NextFrom

	return nil
}

// PagedValidationError is the validation error returned by Paged.Validate if
// the designated constraints aren't met.
type PagedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagedValidationError) ErrorName() string { return "PagedValidationError" }

// Error satisfies the builtin error interface
func (e PagedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaged.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagedValidationError{}

// Validate checks the field values on PagedIDs with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *PagedIDs) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for HasMore

	// no validation rules for NextFrom

	return nil
}

// PagedIDsValidationError is the validation error returned by
// PagedIDs.Validate if the designated constraints aren't met.
type PagedIDsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagedIDsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagedIDsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagedIDsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagedIDsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagedIDsValidationError) ErrorName() string { return "PagedIDsValidationError" }

// Error satisfies the builtin error interface
func (e PagedIDsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagedIDs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagedIDsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagedIDsValidationError{}

// Validate checks the field values on CountByState with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *CountByState) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Counts

	return nil
}

// CountByStateValidationError is the validation error returned by
// CountByState.Validate if the designated constraints aren't met.
type CountByStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountByStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountByStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountByStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountByStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountByStateValidationError) ErrorName() string { return "CountByStateValidationError" }

// Error satisfies the builtin error interface
func (e CountByStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountByState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountByStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountByStateValidationError{}

// Validate checks the field values on Counts with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Counts) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Counts

	return nil
}

// CountsValidationError is the validation error returned by Counts.Validate if
// the designated constraints aren't met.
type CountsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountsValidationError) ErrorName() string { return "CountsValidationError" }

// Error satisfies the builtin error interface
func (e CountsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCounts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountsValidationError{}

// Validate checks the field values on HasRelationsReq with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *HasRelationsReq) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HasRelationsReqValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HasRelationsReqValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// HasRelationsReqValidationError is the validation error returned by
// HasRelationsReq.Validate if the designated constraints aren't met.
type HasRelationsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HasRelationsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HasRelationsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HasRelationsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HasRelationsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HasRelationsReqValidationError) ErrorName() string { return "HasRelationsReqValidationError" }

// Error satisfies the builtin error interface
func (e HasRelationsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHasRelationsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HasRelationsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HasRelationsReqValidationError{}

// Validate checks the field values on HasRelations with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *HasRelations) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Relations

	return nil
}

// HasRelationsValidationError is the validation error returned by
// HasRelations.Validate if the designated constraints aren't met.
type HasRelationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HasRelationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HasRelationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HasRelationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HasRelationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HasRelationsValidationError) ErrorName() string { return "HasRelationsValidationError" }

// Error satisfies the builtin error interface
func (e HasRelationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHasRelations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HasRelationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HasRelationsValidationError{}

// Validate checks the field values on GetRelationReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *GetRelationReq) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRelationReqValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Relation

	if v, ok := interface{}(m.GetLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRelationReqValidationError{
				field:  "Limit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetRelationReqValidationError is the validation error returned by
// GetRelationReq.Validate if the designated constraints aren't met.
type GetRelationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRelationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRelationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRelationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRelationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRelationReqValidationError) ErrorName() string { return "GetRelationReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRelationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRelationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRelationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRelationReqValidationError{}

// Validate checks the field values on EX with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *EX) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EXValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRelated() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EXValidationError{
					field:  fmt.Sprintf("Related[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EXValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if v, ok := interface{}(m.GetCounts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EXValidationError{
				field:  "Counts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetHasRelations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EXValidationError{
				field:  "HasRelations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Children

	return nil
}

// EXValidationError is the validation error returned by EX.Validate if the
// designated constraints aren't met.
type EXValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EXValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EXValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EXValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EXValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EXValidationError) ErrorName() string { return "EXValidationError" }

// Error satisfies the builtin error interface
func (e EXValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEX.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EXValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EXValidationError{}

// Validate checks the field values on EXPaged with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *EXPaged) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EXPagedValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HasMore

	// no validation rules for NextFrom

	return nil
}

// EXPagedValidationError is the validation error returned by EXPaged.Validate
// if the designated constraints aren't met.
type EXPagedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EXPagedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EXPagedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EXPagedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EXPagedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EXPagedValidationError) ErrorName() string { return "EXPagedValidationError" }

// Error satisfies the builtin error interface
func (e EXPagedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEXPaged.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EXPagedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EXPagedValidationError{}

// Validate checks the field values on EXList with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *EXList) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EXListValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// EXListValidationError is the validation error returned by EXList.Validate if
// the designated constraints aren't met.
type EXListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EXListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EXListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EXListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EXListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EXListValidationError) ErrorName() string { return "EXListValidationError" }

// Error satisfies the builtin error interface
func (e EXListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEXList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EXListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EXListValidationError{}

// Validate checks the field values on GetByQueryReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *GetByQueryReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_GetByQueryReq_Type_Pattern.MatchString(m.GetType()) {
		return GetByQueryReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	for idx, item := range m.GetQueries() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetByQueryReqValidationError{
					field:  fmt.Sprintf("Queries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Sorts

	if v, ok := interface{}(m.GetLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetByQueryReqValidationError{
				field:  "Limit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetByQueryReqValidationError is the validation error returned by
// GetByQueryReq.Validate if the designated constraints aren't met.
type GetByQueryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetByQueryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetByQueryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetByQueryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetByQueryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetByQueryReqValidationError) ErrorName() string { return "GetByQueryReqValidationError" }

// Error satisfies the builtin error interface
func (e GetByQueryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetByQueryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetByQueryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetByQueryReqValidationError{}

var _GetByQueryReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on UpdateContentReq with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *UpdateContentReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_UpdateContentReq_Type_Pattern.MatchString(m.GetType()) {
		return UpdateContentReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		return UpdateContentReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
	}

	for idx, item := range m.GetUpdates() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateContentReqValidationError{
					field:  fmt.Sprintf("Updates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// UpdateContentReqValidationError is the validation error returned by
// UpdateContentReq.Validate if the designated constraints aren't met.
type UpdateContentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateContentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateContentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateContentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateContentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateContentReqValidationError) ErrorName() string { return "UpdateContentReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateContentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateContentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateContentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateContentReqValidationError{}

var _UpdateContentReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on SetStateReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *SetStateReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_SetStateReq_Type_Pattern.MatchString(m.GetType()) {
		return SetStateReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			return SetStateReqValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
		}

	}

	// no validation rules for State

	return nil
}

// SetStateReqValidationError is the validation error returned by
// SetStateReq.Validate if the designated constraints aren't met.
type SetStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetStateReqValidationError) ErrorName() string { return "SetStateReqValidationError" }

// Error satisfies the builtin error interface
func (e SetStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetStateReqValidationError{}

var _SetStateReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on DeleteReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *DeleteReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_DeleteReq_Type_Pattern.MatchString(m.GetType()) {
		return DeleteReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			return DeleteReqValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
		}

	}

	return nil
}

// DeleteReqValidationError is the validation error returned by
// DeleteReq.Validate if the designated constraints aren't met.
type DeleteReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteReqValidationError) ErrorName() string { return "DeleteReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteReqValidationError{}

var _DeleteReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on GetCountsReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *GetCountsReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_GetCountsReq_Type_Pattern.MatchString(m.GetType()) {
		return GetCountsReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		return GetCountsReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
	}

	return nil
}

// GetCountsReqValidationError is the validation error returned by
// GetCountsReq.Validate if the designated constraints aren't met.
type GetCountsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCountsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCountsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCountsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCountsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCountsReqValidationError) ErrorName() string { return "GetCountsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetCountsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCountsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCountsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCountsReqValidationError{}

var _GetCountsReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on SetMetaReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *SetMetaReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_SetMetaReq_Type_Pattern.MatchString(m.GetType()) {
		return SetMetaReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		return SetMetaReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
	}

	// no validation rules for Meta

	return nil
}

// SetMetaReqValidationError is the validation error returned by
// SetMetaReq.Validate if the designated constraints aren't met.
type SetMetaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetMetaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetMetaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetMetaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetMetaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetMetaReqValidationError) ErrorName() string { return "SetMetaReqValidationError" }

// Error satisfies the builtin error interface
func (e SetMetaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetMetaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetMetaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetMetaReqValidationError{}

var _SetMetaReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on DeleteMetaReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *DeleteMetaReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_DeleteMetaReq_Type_Pattern.MatchString(m.GetType()) {
		return DeleteMetaReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		return DeleteMetaReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
	}

	return nil
}

// DeleteMetaReqValidationError is the validation error returned by
// DeleteMetaReq.Validate if the designated constraints aren't met.
type DeleteMetaReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMetaReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMetaReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMetaReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMetaReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMetaReqValidationError) ErrorName() string { return "DeleteMetaReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMetaReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMetaReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMetaReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMetaReqValidationError{}

var _DeleteMetaReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")

// Validate checks the field values on UpdateTagsReq with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *UpdateTagsReq) Validate() error {
	if m == nil {
		return nil
	}

	if !_UpdateTagsReq_Type_Pattern.MatchString(m.GetType()) {
		return UpdateTagsReqValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]{1,14}$\"",
		}
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		return UpdateTagsReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
	}

	return nil
}

// UpdateTagsReqValidationError is the validation error returned by
// UpdateTagsReq.Validate if the designated constraints aren't met.
type UpdateTagsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTagsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTagsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTagsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTagsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTagsReqValidationError) ErrorName() string { return "UpdateTagsReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateTagsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTagsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTagsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTagsReqValidationError{}

var _UpdateTagsReq_Type_Pattern = regexp.MustCompile("^[a-z][a-z0-9]{1,14}$")
